<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE subsection PUBLIC "urn:pubid:dita4practitioners.com:doctypes:dita:subsection" "subsection.dtd"> 
<subsection id="step2-3">
	<title>Step 2-3. Declare Elements and Attributes</title>
	<?oxy_delete author="jdwin" timestamp="20200107T162931-0500" content="&lt;body&gt;&lt;p&gt;For each element type, create an element type and attribute declaration: &lt;codeblock&gt;
&amp;lt;!-- ====================================================
     XML Construct Domain Module
    
     Author: &lt;i&gt;your name here&lt;/i&gt;

     Copyright (c) 2011 &lt;i&gt;copyright holder&lt;/i&gt;
     
     &lt;i&gt;license to use or not use or whatever&lt;/i&gt;
     ==================================================== --&gt;
 
&amp;lt;!ENTITY % xmlelem    &quot;xmlelem&quot;  &gt;

&lt;b&gt;&amp;lt;!--                    LONG NAME: XML Element                            --&gt;
&amp;lt;!ENTITY % xmlelem.content 
  &quot; 
  (#PCDATA)*
  &quot;
&gt;
&amp;lt;!ENTITY % xmlelem.attributes
  &apos;
  %univ-atts;          
  keyref
    CDATA
    #IMPLIED
  outputclass 
    CDATA
    #IMPLIED    
  &apos;
&gt;
&amp;lt;!ELEMENT xmlelem %xmlelem.content; &gt;
&amp;lt;!ATTLIST xmlelem %xmlelem.attributes; &gt;
&lt;/b&gt;          &lt;/codeblock&gt;&lt;/p&gt;&lt;p&gt;Note that the content model for each element type must be at least as restrictive as the content model of the specialization base (in this case, &lt;xmlelement&gt;keyword&lt;/xmlelement&gt;, although we haven&apos;t declared that yet). Looking at the DITA language reference (or the declaration in commonElements.mod), we see that the content model for &lt;xmlelement&gt;keyword&lt;/xmlelement&gt; includes both #PCDATA as well as all other phrase-level elements. Since the XML component mentions don&apos;t need or want any subelements, we&apos;ve reduced the content model down to just #PCDATA (just text), which is consistent with the content model of the &lt;xmlelement&gt;keyword&lt;/xmlelement&gt; element.&lt;/p&gt;&lt;p&gt;Note also that the content model and attribute lists are defined as parameter entities that are then used in the actual ELEMENT and ATTLIST declarations. (This is a change from DITA 1.1 to DITA 1.2 made to enable overriding of individual element&apos;s content models and attribute lists through constraint modules. ) In this case the only content model more restrictive than &quot;&lt;codeph&gt;(#PCDATA)*&lt;/codeph&gt;&quot; is &quot;&lt;codeph&gt;EMPTY&lt;/codeph&gt;&quot;.)&lt;/p&gt;&lt;note type=&quot;other&quot; othertype=&quot;Common Errors&quot;&gt;&lt;p&gt;Attributes with quoted default values quoted with the same quote character as the parameter entity text.&lt;/p&gt;&lt;p&gt;In parameter entity declarations you can use either single quotes or double quotes (&quot; or &apos;) to quote the entity value. Because attributes can have literal default values, you have to make sure the quotes used for the attribute value are different from the quotes used for the parameter entity text itself. This is most common with specializations of &lt;xmlelement&gt;data&lt;/xmlelement&gt; where you want to set the &lt;xmlatt&gt;name&lt;/xmlatt&gt; attribute to a specific value (typically the tagname of the specialization).&lt;/p&gt;&lt;p&gt;For attribute declarations it&apos;s usually easiest to use single quotes so that attributes that specify literal default values can use double quotes, which is how most American&apos;s will declare them (and thus what you are most likely to copy from the base DITA declarations). Of course, if you&apos;re British you can swap that around.&lt;/p&gt;&lt;p&gt;An attributes parameter entity with a quoted default value would look like this:&lt;codeblock&gt;&amp;lt;!ENTITY % myDataElem.attributes 
  &apos;
    name
       CDATA
       &lt;b&gt;&quot;myDataElem&quot;&lt;/b&gt;
    value
       CDATA
       #REQUIRED
    %univ-atts;
  &apos;
&gt;&lt;/codeblock&gt;&lt;/p&gt;&lt;/note&gt;&lt;/body&gt;"?>
	<?oxy_insert_start author="jdwin" timestamp="20200107T162931-0500"?>
	<body>
		<p>For each element type, create an element type and attribute declaration:
			<codeblock>&lt;!-- ====================================================
     DocBook-like Paragraph Domain Module
    
     Author: <i>your name here</i>

     Copyright (c) 2019 <i>copyright holder</i>
     
     <i>license to use or not use or whatever</i>
          
     ==================================================== -->
 
&lt;!ENTITY % para    "para"  >

<b>&lt;!--                    LONG NAME: DocBook-like Paragraph                            -->
&lt;!ENTITY % para.content 
  " 
  (#PCDATA)*
  "
>
&lt;!ENTITY % para.attributes
  '
  %univ-atts;          
  keyref
    CDATA
    #IMPLIED
  outputclass 
    CDATA
    #IMPLIED    
  '
>
&lt;!ELEMENT para %para.content; >
&lt;!ATTLIST para %para.attributes; ></b></codeblock></p>
		<p>Note that the content model for each element type must be at least as restrictive as the
			content model of the specialization base (in this case, <xmlelement>keyword</xmlelement>,
			although we haven't declared that yet). Looking at the DITA language reference (or the
			declaration in commonElements.mod), we see that the content model for
				<xmlelement>keyword</xmlelement> includes both #PCDATA as well as all other phrase-level
			elements. Since the XML component mentions don't need or want any subelements, we've reduced
			the content model down to just #PCDATA (just text), which is consistent with the content model
			of the <xmlelement>keyword</xmlelement> element.</p>
		<p>Note also that the content model and attribute lists are defined as parameter entities that
			are then used in the actual ELEMENT and ATTLIST declarations. (This is a change from DITA 1.1
			to DITA 1.2 made to enable overriding of individual element's content models and attribute
			lists through constraint modules. ) In this case the only content model more restrictive than
				"<codeph>(#PCDATA)*</codeph>" is "<codeph>EMPTY</codeph>".)</p>
		<note type="other" othertype="Common Errors">
			<p>Attributes with quoted default values quoted with the same quote character as the parameter
				entity text.</p>
			<p>In parameter entity declarations you can use either single quotes or double quotes (" or ')
				to quote the entity value. Because attributes can have literal default values, you have to
				make sure the quotes used for the attribute value are different from the quotes used for the
				parameter entity text itself. This is most common with specializations of
					<xmlelement>data</xmlelement> where you want to set the <xmlatt>name</xmlatt> attribute to
				a specific value (typically the tagname of the specialization).</p>
			<p>For attribute declarations it's usually easiest to use single quotes so that attributes
				that specify literal default values can use double quotes, which is how most American's will
				declare them (and thus what you are most likely to copy from the base DITA declarations). Of
				course, if you're British you can swap that around.</p>
			<p>An attributes parameter entity with a quoted default value would look like
				this:<codeblock>&lt;!ENTITY % myDataElem.attributes 
  '
    name
       CDATA
       <b>"myDataElem"</b>
    value
       CDATA
       #REQUIRED
    %univ-atts;
  '
></codeblock></p>
		</note>
	</body>
	<?oxy_insert_end?>
</subsection>
<?oxy_options track_changes="on"?>