<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "urn:pubid:dita4practitioners.com:doctypes:dita:chapter" "chapter.dtd">
<chapter
  id="topic-id">
  <title>Reuse at the Element Level: The Content Reference Facility</title>
  <shortdesc>DITA provides a powerful use-by-reference facility that allows almost any element to be
    used by reference from maps or topics as long as specific constraints are met. This facility is
    the <q>content reference facility</q> or <q>conref</q> for short. </shortdesc>
  <prolog>
    <metadata>
      <keywords>
        <indexterm>reuse</indexterm>
        <indexterm>conref</indexterm>
        <indexterm>content reference facility<index-see>conref</index-see></indexterm>
        <indexterm>use by copy</indexterm>
        <indexterm>use by reference</indexterm>
        <indexterm>link<indexterm>use by reference</indexterm></indexterm>
      </keywords>
    </metadata>
  </prolog>
  <body>
    <p>The conref facility uses two main attributes, <xmlatt>conref</xmlatt> and
        <xmlatt>conkeyref</xmlatt>. With these attributes, you can create a link were the referenced
      element is processed as though it were located at the point of reference.</p>
    <p>For example, you might manage standard <xmlelement>note</xmlelement> elements in one topic like the
      following:<codeblock>&lt;topic id="standard-notes">
  &lt;title>Standard Notes&lt;/title>
  &lt;body>
   &lt;note id="dont-run-scissors">Don't
run with scissors.&lt;/note>
   &lt;note id="hands-inside">Keep
hands inside the car when it's moving&lt;/note>
   ...
&lt;/topic></codeblock></p>
    <p>Within other topics, you can create <xmlelement>note</xmlelement> elements that
      link to the standard notes:
      <codeblock>&lt;task id="making-snowflake">
  &lt;title>Making Paper Snowflakes&lt;/title>
  &lt;taskbody>
    &lt;context>
     <b>&lt;note</b> 
      <b>conref="standard-notes.dita#standard-notes/dont-run-scissors"/></b>
     ...
&lt;/task></codeblock></p>
    <p>The result for each reference is that the referenced note is processed as though it had
            occurred in place of the referencing note. Thus, the <q>Making Paper Snowflakes</q> task
            will show the <q>Don’t run with scissors</q> note when it’s rendered. If the note text
            is changed, then all users of the note will reflect the next text the next time they are
            rendered. (Note that this example uses a direct <xmlatt>conref</xmlatt> reference for
            simplicity. In practice you should use key references for content references.)</p>
    <p>By <term>use by reference</term> I mean using something without copying it. Use by reference
      is important because it allows a single piece of content to exist in exactly one place and be
      used in many places.</p>
    <p>The practical benefits of use by reference include minimizing writing effort by not having to
      maintain multiple copies, minimizing localization costs by allowing the same localized content
      to be used many times, and enabling the creation of new publications from existing content
      with a minimum of effort.</p>
    <p>Use by reference is not without costs, however. Once a piece of content is used in two places
      you have a management challenge; you must know about all uses and coordinate changes with
      anyone who uses that content. This coordination is either explicit, meaning you have to
      communicate with users, or implicit, meaning you need business rules or component management
      features that help ensure that the correct thing is done when things change.</p>
    <p>The alternative to use by reference is <term>use by copy</term>. Use by copy means literally
            copying something and then using the new copy in a new context, i.e., <q>cut and
                paste.</q> Use by copy is easy to do because it doesn’t require any linking or
            content management facilities, but it has the problem that it results in multiple copies
            of what is often essentially the same content, copies that then have to be kept in sync.
            In most cases, copies are not tracked, meaning that the knowledge of the original source
            of the copy is not maintained in a manageable way. </p>
    <p>As an information management practice, use by copy is usually the wrong
      thing to do (although it’s not always wrong). Some component management
      systems<indexterm>component management system<indexterm>copy tracking
      with</indexterm></indexterm> track copy actions, providing a record of
      what was copied from where and when. To create appropriate information use
      and reuse policies you must clearly distinguish use by copy from use by
      reference and define when it is appropriate to use one or the other. If
      you allow use by copy, you need to define record-keeping requirements to
      keep track of the location of any copies. DITA does not provide any
      built-in attributes or metadata elements for capturing use-by-copy
      information.</p>
    <p>Use by reference is a form of
      hyperlinking<indexterm>hyperlink<indexterm>for use by
      reference</indexterm></indexterm><indexterm>use by reference<indexterm>as
      hyperlinking</indexterm></indexterm> and, therefore, brings with it some
      of the fundamental challenges of hyper-document
      management<indexterm>hyper-document
      management</indexterm><indexterm>management<indexterm>of
      hyper-documents</indexterm></indexterm>. A use-by-reference link
      establishes a dependency<indexterm>dependencies<indexterm>from
      use-by-reference
      links</indexterm></indexterm><indexterm>dependencies<indexterm>tracking</indexterm></indexterm><indexterm>management<indexterm>of
      dependencies</indexterm></indexterm> that has to be tracked and
      managed.</p>
    <p>For example, if Topic A reflects release 1.0 of a product and re-uses by reference a
      paragraph from Topic B, what happens when Topic B is updated to reflect release 1.1 of the
      product? Topic A has to decide which version of the paragraph from Topic B it should now use:
      The original version? The new version? A third, yet-to-be-created version?</p>
    <p>If you coordinated the development of topics A and B, then that may not be a problem, but if
            you haven’t, then you need to evaluate the development and management processes that
            created topics A and B. The eventual answer might be <q>always reflect latest</q> or it
            might not be. You might realize you need to start using DITA’s conditional processing
            features to handle the release-specific content, or you might need a component
            management system that provides version-aware addressing facilities.</p>
    <p>The point is that while use by reference is powerful and can address difficult business
            challenges, it also introduces complexity that must be considered carefully. In more
            than 20 years working with and building systems for complex documents, I have found that
            use by reference is used much less frequently than many people expect when they first
            move to XML. I think this is because people find that the management cost and source
            data complexity outweighs the benefit or at least appears to. That is, sometimes it’s
            easier (or appears to be easier) to just make copies and manage the copies than it is to
            use direct use by reference.</p>
    <p>Your mileage will vary of course. You have to think carefully about local requirements, your
            tools, your authors’ capabilities and enthusiasm, and your business goals and
            requirements. In general, if you can limit use by reference to the topic level using
            maps or to specific cases where the benefit is clear, such as re-used warnings or steps,
            then things will be easier. But allowing authors free reign to reuse anything from
            anywhere is probably a non-starter for most environments.</p>
  </body>
  <subsection
    id="subsection_xoc_zyg_hb">
    <title>Use by reference in the world</title>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>external parsed entity</indexterm>
          <indexterm>use by copy</indexterm>
          <indexterm>XInclude</indexterm>
          <indexterm>entity<indexterm>XML</indexterm></indexterm>
          <indexterm>XML<indexterm>entity</indexterm></indexterm>
          <indexterm>SGML</indexterm>
          <indexterm>IBM ID Doc</indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>Before diving into DITA’s use-by-reference facilities, let’s discuss the things DITA
                doesn’t use and why.</p>
      <p>The most obvious one is XML external parsed entities.</p>
      <p>External parsed entities are an XML feature that is a hold over from SGML. External parsed
                entities (often informally referred to as <q>file entities</q>) are fragments of XML
                documents that are stored as separate resources (for example, separate files) and
                referenced from the root XML document (directly or indirectly) using an inline
                entity reference. The entity’s content (the <q>replacement text</q>) is parsed in
                the context of the reference, meaning that any markup in the entity must be valid at
                the point of reference.</p>
      <p>External parsed entities are not use by reference, they are use by copy. This is because
                entities are essentially string macros, not objects in the computer science sense.
                The parsing effect of an entity reference is <i>identical</i> to having cut and
                pasted the content of the entity at the point of reference. This means entity
                references are not objects in the way that XML elements are; you can’t put
                attributes on them and parsers are not obligated to preserve them or report them to
                other processors. Many XML-aware repositories do not preserve entities, which means
                that knowledge of the original entities is lost when XML is put into the repository.
                This is true of the MarkLogic product, for example.</p>
      <p>Finally, entities can only be defined using a DOCTYPE declaration. DOCTYPE declarations are
        not required by XML or DITA.</p>
      <p>For all these reasons, and more, external parsed entities are not a good idea (I am on
                record many times as saying <q>entities are evil,</q> and I stand by that
                statement). My greatest regret as a member of the XML Working Group is that I fought
                to retain entities in XML, when I should have fought to eliminate them.</p>
      <p>External parsed entities provide the <i>illusion</i> of reuse without actually providing
        it, leading many people astray. DITA correctly and explicitly does not support or encourage
        the use of external parsed entities. DITA cannot disallow their use, but it is certainly not
        DITA practice to use entities, and if you are using them you should stop immediately. The
        DITA content reference facility is designed, in part, to satisfy the requirements that
        people thought external parsed entities would satisfy, but that they do not.</p>
      <p>Another XML facility is XInclude. XInclude provides a markup-based facility that allows
        reference to XML content using links. It is better than external parsed entities because it
        is markup based (meaning it uses elements rather than something else), but it is not much
        better than external parsed entities because its behavior is essentially use by copy, not
        use by reference.</p>
      <p>There are three reasons for this:</p>
      <p>
        <ol id="ol_x2f_fhm_wf">
          <li>XInclude is intended to be applied during parsing, rather than after parsing, which
            means processing applications cannot control the results.</li>
          <li>XInclude has no provision for ID and pointer rewriting, which effectively means that
            XML IDs must be unique across all documents being processed.</li>
          <li>XInclude provides no way to constrain the location of includes or the content being
                        included. This means you can’t control how and where authors do inclusions
                        using content model constraints, markup design, or other XML
                        facilities.</li>
        </ol>
      </p>
      <p>So XInclude is no good, at least for authoring. Like other W3C standards it might be useful
                for delivery, but that’s a pretty rare use.</p>
      <p>Some parsers do support XInclude natively, such as the Xerces parser,
        but because it requires using the <xmlelement>xi:include</xmlelement> element
        in your documents, which DITA explicitly does not include in any form,
        it is impossible to have a valid and conforming DITA document that uses
        XInclude.</p>
      <p>In fact, DITA’s content reference facility predates XML and XInclude by a decade, since it
                reflects features that were originally designed for the IBM ID Doc document type
                back in the late 80’s and early 90’s, which were designed to overcome deficiencies
                in SGML’s entity mechanisms. At this time, DITA probably has the most complete and
                general element- and link-based, use-by-reference solution of any general XML
                application.</p>
      <p>If you want to determine whether or not a given content modularity feature is use by
        reference or use by copy the test is simple: what happens when a chunk of XML content that
        contains an XML ID is used twice in the same parent context?</p>
      <p>If the answer is <q>the ID attributes and references to them are not modified,</q> that is,
        the result is the same as if you cut and pasted the content into both locations, then you
        have use by copy. If the answer is <q>the IDs are made unique in the use context, and
          references to them are modified to be correct following resolution</q> then you have use
        by reference.</p>
      <p>This test applies to <i>all</i> forms of identifiers and the addresses that use them, not
                just XML IDs. I use XML IDs in the statement of the test because they’re obvious.
                But the requirement applies to any form of address whatsoever, since addresses must
                continue to be correct after resolving the references, whatever <q>correct</q>
                means. XML IDs are just an obvious way of revealing the problem.</p>
      <p>Because managing IDs and their attendant references requires processing that understands
                the semantics of the content, not just its syntax, true use-by-reference facilities
                cannot be implemented at the syntax level, that is, at the parsing level. Both
                external parsed entities and XInclude fail the test because they are syntactic, not
                semantic. By contrast, DITA’s conref facility and its map facility are semantic,
                being handled by a DITA-aware processor following parsing of the individual XML
                documents involved. That means the processors have full knowledge of both the
                original data content and the semantics of the identifiers and addresses and can
                therefore do whatever needs to be done to ensure that the resolved result is
                correct. </p>
      <p>In the case of element IDs and references to them, DITA has specific rules to ensure that
        authors can create links and addresses that are correct as authored and that will be correct
        following use-by-reference resolution. This capability distinguishes DITA from essentially
        all other XML documentation applications, none of which have an equivalent true
        use-by-reference facility.</p>
    </body>
  </subsection>
  <subsection
    id="ss1">
    <title>Basic Conref: Reusing Single Elements</title>
    <shortdesc>The simplest application of conref is a single element using another single element.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>element-to-element</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>A typical use case is re-using notes, cautions, warnings, and other content developed and
        maintained by groups, such as a Legal department, that create content authors should not be
        writing or modifying. The general term for notes, cautions, and warnings is
          <term>admonitions</term>, although this is not a term used in the DITA standard.</p>
      <p>To use conref you need two things:<ol id="ol_vhm_efo_hb">
          <li>A topic that contains the element to be used by reference. Elements to be used by
            reference must have <xmlatt>id</xmlatt> attributes so they can be addressed using normal
            DITA addressing syntax.</li>
          <li>An element of the same, <i>or less specialized,</i> type that points to the element to
            be reused. Any constraints on the two elements must be compatible, meaning that the
            element to be reused must be at least as constrained as the referencing element. See
              <xref href="#subsection_gsu_mxu_hb" format="dita"/> for details.</li>
        </ol></p>
      <p>For this example we have a topic containing a set of admonitions
        intended to be used by
        reference:<codeblock>&lt;?xml version="1.0"?>
&lt;!DOCTYPE topic PUBLIC "urn:my:local:topic:shell" "topic.dtd">
&lt;topic id="admonitions">
  &lt;title>Common Admonitions for Tasks&lt;/title>
  &lt;body>
    <b>&lt;note id="note-01" type="caution">This is note one.&lt;/note></b>
    <b>&lt;note id="note-02" type="danger">This is note two.&lt;/note></b>
    <b>&lt;note id="note-03" type="warning">This is note three.&lt;/note></b>
  &lt;/body>
&lt;/task></codeblock></p>
      <p>Because this topic only exists to hold elements for reuse, topicrefs that reference it
                should set <xmlatt>processing-role</xmlatt> to <q>resource-only, </q>, for
                example:<codeblock>&lt;map>
  ...
  &lt;topicgroup>
    <b>&lt;topicref 
       href="common/tasks/admonition-set-01.dita"
       processing-role="resource-only"
    /></b>
    ...
  &lt;/topicgroup>
 ...
&lt;/map></codeblock></p>
      <p>If you will have a number of such resource topics, you can make the map simpler by moving the <xmlatt>processing-role</xmlatt> attribute to an ancestor <xmlelement>topicgroup</xmlelement> or <xmlelement>topichead</xmlelement> element:<codeblock>&lt;map>
  ...
  &lt;topicgroup
    <b>processing-role="resource-only"</b>
  >
    &lt;topicref 
      href="common/tasks/admonition-set-01.dita"       
    />
    ...
  &lt;/topicgroup>
 ...
&lt;/map></codeblock></p>
      <p>The attributes of the ancestor element cascade to the descendant elements, so this example
        sets the effective value of <xmlatt>processing-role</xmlatt> to <q>resource-only</q> for all
        the topicrefs under the topic group.</p>
      <p>To use one of the notes within a real task, you simply use a <xmlelement>note</xmlelement>
        element with the <xmlatt>conref</xmlatt>
        attribute:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      <b>&lt;note conref="../../common/tasks/admonition-set-01.dita#admonitions/note-01"/></b>
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Normally, the processor will render the referenced note at the point where the
          <xmlelement>note</xmlelement> element with the <xmlatt>conref</xmlatt> attribute occurs.</p>
      <p>I say <q>normally</q> because content reference processing is not 100% mandatory—you could
                implement a processor that did something else. That’s possible because conref
                processing is semantic, meaning it occurs after the XML data has been parsed. It is
                not a function of the XML parsing like handling entities or XInclude is.</p>
            <p>For example, you might implement a processor that produces a <q>conref report</q>
                that shows what the references are rather than resolving them. The DITA Open Toolkit
                resolves conrefs during pre-processing, so later processing steps normally see data
                that has had any conrefs resolved. But that’s simply an implementation choice—the
                order in which conref processing is applied is not mandated by the DITA
                standard.</p>
    </body>
  </subsection>
  <subsection
    id="subsection_wqk_vaf_id">
    <title>Conkeyref</title>
    <prolog>
      <metadata>
        <keywords>
          <indexterm><xmlatt>conref</xmlatt></indexterm>
          <indexterm><xmlatt>conkeyref</xmlatt></indexterm>
          <indexterm>key-based content reference</indexterm>
          <indexterm>conref<indexterm>using key references</indexterm></indexterm>
          <indexterm>conref<indexterm>key-based</indexterm></indexterm>
          <indexterm>key reference<indexterm>for content
            reference</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>In the preceding example, the <xmlatt>conref</xmlatt> attribute is a direct pointer to the
        admonition set topic. As discussed in the section on linking and addressing, this
        establishes a hard dependency between the using task and the admonition set task. In
        addition, the reference depends on all the files being in the correct relative location.</p>
      <p>A more flexible approach is to replace <xmlatt>conref</xmlatt> with
          <xmlatt>conkeyref</xmlatt>. We can quickly rework the example to use keys by adding a
          <xmlatt>keys</xmlatt> attribute to the topicref for the admonition set topic and replacing
          <xmlatt>conref</xmlatt> with <xmlatt>conkeyref</xmlatt> on the <xmlelement>note</xmlelement>
        element:<codeblock>&lt;map>
  ...
  &lt;topicgroup>
    &lt;topicref 
       <b>keys="admonition-set-01"</b>
       href="common/tasks/admonition-set-01.dita"
       processing-role="resource-only"
    />
    ...
  &lt;/topicgroup>
 ...
&lt;/map></codeblock></p>
      <p>And in the using topic:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      <b>&lt;note conkeyref="admonition-set-01/note-01"/></b>
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Now the conref is not sensitive to the specific location of the admonition set topic. In
        addition, different root maps could provide different sets of admonitions for different
        purposes, for example, different regulatory environments, national languages, or product
        versions.</p>
      <p>Note that the value of the <xmlatt>conkeyref</xmlatt> attribute is the key name, a slash,
        and the element ID of the target note. There is no need to specify the ID of the topic
        element in the <xmlatt>conkeyref</xmlatt> because the key-defining topicref already
        addresses the appropriate topic.</p>
      <p>In this example the ID of the note is just <q>note-01,</q> but in practice you would
                probably give specific elements IDs that reflect their purpose, for example,
                    <q>dont-run-with-scissors</q> for the <q>Don’t run with scissors</q> danger
                admonition. </p>
      <p>Because keyref requires topics to use the actual ID value of the
        referenced element, it makes sense to assign meaningful IDs that clearly
        identify the purpose of the element, regardless of whether it's intended
        for use by reference or as the target of cross references or other
        navigation links.</p>
    </body>
  </subsection>
  <subsection
    id="subsection_yha_epc_ib">
    <title>Conref for maps and topics</title>
    <shortdesc>The DITA content reference facility applies to all DITA content, not just topics. This means you can use conref in maps as well as in topics.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>within maps</indexterm></indexterm>
          <indexterm>maps<indexterm>conref  within</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>As far as I can tell it’s fairly rare for people to use conref within maps for the simple
                reason that DITA already provides good facilities for constructing compound maps
                using topicrefs. Nevertheless, you can use conref with maps, and there may be
                information management challenges that are best met using conref in maps (although I
                have not encountered any in my own work). Certainly all conforming DITA processors
                must be prepared to apply conref resolution processing to maps.</p>
      <p>The main caveat for conref within maps is that you cannot reliably use conref to configure
        or create key definitions, because you cannot resolve key-based conrefs without first having
        constructed the key space. If you used key-based conrefs to construct key-defining
        topicrefs, those topicrefs can have no effect on the key space. While a processor could
        choose to first resolve all direct conrefs, then build the key space, and then resolve all
        key-based conrefs, DITA does not require processors to work that way. So any map
        construction scheme that relied on some interaction between conref and key definitions would
        be dicey at best.</p>
      <p>When doing conref within maps, keep in mind that the fragment identifiers for map elements
        are simply bare <xmlatt>id</xmlatt> values, because each map document is a single ID
        namespace (as though all <xmlatt>id</xmlatt> attributes had been declared as type ID).</p>
      <p>Within topics you could use conref to nest topics within other topics
        without using a map. However, there’s little obvious reason to do this
        instead of using maps to create hierarchies of topics. Because you can
        create submaps<indexterm>submap<indexterm>reuse
        of</indexterm></indexterm><indexterm>map<indexterm>submap</indexterm></indexterm>
        and re-use them from other maps, you can create small maps that combine
        a few topics to form a single unit of re-use. For example, you could
        create a map to combine a task, one or more supporting concepts, and one
        or more supporting reference topics. [Citation to original IBM paper on
        this subject]</p>
      <p>Note that you cannot use <xmlelement>topicref</xmlelement> within <xmlelement>topic</xmlelement>, where you might have expected it to be allowed. Topicrefs occur only within maps.</p>
    </body>
  </subsection>
  <subsection
    id="subsection_rqq_gto_hb">
    <title>Attribute Merging</title>
    <shortdesc>The attributes on the referencing element and referenced elements are merged according to strict rules.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>attribute merging rules</indexterm></indexterm>
          <indexterm>attributes<indexterm>merging through conref</indexterm></indexterm>
          <indexterm>-dita-use-conref-target attribute value</indexterm>
          <indexterm>use-conref-target attribute value<index-see>-dita-use-conref-target attribute value</index-see></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>When an element uses another element by reference the attributes of the referencing element
        and the referenced element are merged, and the attributes of the referencing element take
        precedence over the attributes of the referenced element.</p>
      <p>In the re-used note example, the referenced <xmlelement>note</xmlelement> specifies the
          <xmlatt>type</xmlatt> attribute with the value <q>caution.</q> Because the referencing
        element does not also specify <xmlatt>type</xmlatt>, the effective value of
          <xmlatt>type</xmlatt> following conref resolution will be <q>caution.</q></p>
      <p>But if the referencing element specified a different value, that value would take
        precedence. For example, this use results in an effective <xmlatt>type</xmlatt> value of
          <q>danger</q>:</p>
      <codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition-set-01/note-01"
            <b>type="danger"</b>/>
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock>
      <p>The default attribute merge behavior can be reversed by using the value
                    <q>-dita-use-conref-target</q> for that attribute on the referencing element.
                This is needed for attributes that are declared as an enumerated set of values with
                a default. In that case the attribute will always have some value on the referencing
                element (because of the default), so authors need a way to explicitly indicate that
                the referenced element’s attribute should be used in preference to the referencing
                element’s value.</p>
      <p>For example, in a specialization or constraint module you can declare the
                    <xmlatt>type</xmlatt> attribute to use a subset of the values allowed by the
                base vocabulary and set a default value of say <q>note.</q> Then, the original
                example would result in <xmlatt>type</xmlatt> having the value <q>note,</q> rather
                than the value set on the referenced element, because the default attribute on the
                referencing element would override the value on the referenced element. In this
                case, authors would need to specify <q>-dita-use-conref-target</q> on the
                referencing
                element:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition-set-01/note-01"
            <b>type="-dita-use-conref-target"</b>/>
      ...
    &lt;/context>
    &lt;steps>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>This may seem like something of an edge case but in fact it’s probably quite likely,
                because the DITA 1.2 constraint facility makes it easy to tune content models and
                attribute declarations to match local editorial rules and to make things easier for
                authors. But having done that, in particular having set defaults on attributes that
                do not normally have a default value, you must be aware of the implications for
                conref and train authors appropriately, as the typical author would never figure out
                why they weren’t getting the note type they expected.</p>
    </body>
  </subsection>
  <subsection
    id="subsection_jwi_wuo_hb">
    <title>Linking to Referencing Elements</title>
    <shortdesc>You link to the result of conref resolution by linking to the referencing element in the content as authored.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>linking<indexterm>conref considerations</indexterm></indexterm>
          <indexterm>conref<indexterm>linking and addressing considerations</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>Sometimes you need to create a cross-reference to an element that is itself a conref to
        another element. For example, within a task you might need to create a reference to a step
        where the step is used by reference.</p>
      <p>In this case, the referencing element must have an <xmlatt>id</xmlatt> attribute and the cross-reference must point to that ID, <i>not</i> the ID of the content reference target.</p>
      <p>For example, given this set of steps:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition/note-01"
        type="-dita-use-conref-target"
      />
      ...
    &lt;/context>
    &lt;steps>
      <b>&lt;step conkeyref="common-steps/remove-access-cover-step"/></b>
      ...
      &lt;step>
        &lt;cmd>...&lt;/cmd>
        &lt;info>
         &lt;p>You must have performed <b>Step 1</b>.         
         &lt;/p>
        &lt;/info>
      &lt;/step>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Where you want to replace the literal text <q>Step 1</q> with a cross-reference, you would
        first put an ID on the referencing element and then refer to that
        element:<codeblock>&lt;task id="task-id">
  &lt;title>Do Something Useful&lt;/title>
  &lt;taskbody>
    &lt;context>
      &lt;note conkeyref="admonition/note-01"
        type="-dita-use-conref-target"
      />
      ...
    &lt;/context>
    &lt;steps>
      &lt;step <b>id="step-01"</b>
        conkeyref="common-steps/remove-access-cover-step"/>
      ...
      &lt;step>
        &lt;cmd>...&lt;/cmd>
        &lt;info>
         &lt;p>You must have performed 
         <b>&lt;xref href="#task-id/step-01" type="step"/></b>.      
         &lt;/p>
        &lt;/info>
      &lt;/step>
      ...
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>This reflects the general principle that all addresses in the source data should reflect
                the data <i>as authored</i>, not as rendered. By pointing to the referencing
                element, the author’s intent is clear, and there is enough information for the
                processor to do the right thing. By the rules of attribute merging, the
                    <xmlatt>id</xmlatt> attribute of the referencing element will be the effective
                value following conref resolution.</p>
      <p>Or said another way: the IDs of referenced elements are only useful for creating conref
                links, they should have no effect on the content reference result. If you need to
                create a link to the conref result, you must put an ID on the referencing element.
                If you don’t need to link to the conref result, the effective value of the
                    <xmlatt>id</xmlatt> attribute following conref resolution has no effect on
                anything because nothing points to it (other than the original referencing element).
                Because the referencing element has no ID, there is no way to author a link to it,
                and therefore the fact that the effective element might have an effective
                    <xmlatt>id</xmlatt> value after conref resolution is irrelevant—the link cannot
                be authored with respect to the content as it exists in the source. Likewise, any
                conref processor that handles IDs correctly <i>must</i> be prepared to rewrite IDs
                in the resolved result so that two uses of the same element in the same topic or map
                don’t result in duplicate IDs in the resolved result.</p>
    </body>
  </subsection>
  <subsection
    id="subsection_gsu_mxu_hb">
    <title>Content Reference Constraints</title>
    <shortdesc>The content reference facility imposes some constraints on the referencing and
      referenced elements.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>constraints</indexterm></indexterm>
          <indexterm>conref<indexterm>constraint module consistency requirements</indexterm></indexterm>
          <indexterm>constraints<indexterm>on content references</indexterm></indexterm>
          <indexterm>constraint module<indexterm>content reference considerations</indexterm></indexterm>
          <indexterm>general task</indexterm>
          <indexterm>constrained task</indexterm>
          <indexterm>tasks<indexterm>constrained</indexterm></indexterm><indexterm>tasks<indexterm>general</indexterm></indexterm>
          <indexterm><xmlatt>domains</xmlatt> attribute</indexterm>
          <indexterm>attributes<indexterm><xmlatt>domains</xmlatt></indexterm></indexterm>
          <indexterm>domain modules<indexterm>conref considerations</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>The intent of these constraints is to ensure that the resolved result is consistent with the content model rules that apply to the referencing element. In particular, authors should not be able to subvert content model rules by referencing elements that are less constrained.</p>
      <p>The basic rule is that an element can only create a conref to an element of the same type
        or a <i>more specialized</i> type. You cannot create a conref from a more-specialized
        element to a less-specialized element. This rule takes advantage of the DITA requirement
        that specialized elements must be at least as constrained as their base element. That is,
        specializations can never add anything that would be invalid if the more-specialized
        elements were transformed into their less-specialized ancestor types.</p>
      <p>The <i>element</i> you’re using by reference must be the same as or more specialized than
                the element making the reference. However, the topic that contains the referenced
                element may be less specialized than the topic that contains the reference. For
                example, you can use a generic <xmlelement>topic</xmlelement> element to contain re-usable
                    <xmlelement>note</xmlelement> elements but still use those notes from
                    <xmlelement>task</xmlelement> topics. The rule about the used element being the same
                or more specialized is only checked for the elements involved, not the topics that
                contain those elements. However, the two topics must use compatible constraint
                modules, as explained below.</p>
      <p>As an example of using more-specialized types from less-specialized elements, say we create
        a new <q>admonition</q> domain that creates distinct element types for the note types
          <q>caution,</q>
        <q>warning,</q> and <q>danger, </q>resulting in elements like the
        following:<codeblock>&lt;warning class="+ topic/note admon-d/warning ">This is a warning&lt;/warning>
&lt;danger class="+ topic/note admon-d/danger ">This is a danger&lt;/danger> </codeblock></p>
      <p>In the DTD, we assign the <xmlelement>warning</xmlelement> element’s <xmlatt>type</xmlatt>
                attribute value to be <q>warning</q> and the <xmlelement>danger</xmlelement> element’s
                    <xmlatt>type</xmlatt> to be <q>danger.</q> We then use this domain to create a
                set of re-usable admonitions similar to the original re-used note example above, but
                using our specializations of <xmlelement>note</xmlelement>. From a topic that needs to use
                one these admonitions by reference, we can use either <xmlelement>note</xmlelement> or the
                specialization as the referencing
                element:<codeblock>&lt;task id="task-id">
  ...
  &lt;context>
    &lt;<b>note</b> conkeyref="admonition-set-02/warning-01"/>
    &lt;<b>warning</b> conkeyref="admonition-set-02/warning-02"/>
  &lt;/context>
  ...
&lt;/task></codeblock></p>
      <p>Both forms of conref are valid. If <xmlelement>note</xmlelement> is the referencing element, the
        referenced element is a more-specialized note (<xmlelement>warning</xmlelement>). If
          <xmlelement>warning</xmlelement> is the referencing element, the referenced element is the same
        element type.</p>
      <p>However, it would not be valid to create a conref from a <xmlelement>warning</xmlelement> element
        to one of the <xmlelement>note</xmlelement> elements from the original example, because the
          <xmlelement>note</xmlelement> elements in that topic are <i>less</i> specialized than
          <xmlelement>warning</xmlelement>.</p>
      <p>There is an additional rule involving the use of constraint modules: the constraints used
        in the referencing document must be consistent with the constraints used in the referenced
        document, which means the referenced document must not be less constrained than the
        referencing document.</p>
      <p>This is why you cannot conref from a DITA 1.1-style constrained task to elements in a DITA
        1.2 general task: the general task in DITA 1.2 uses a constraint module that makes it match
        the DITA 1.1 task model. Because general task does not use this constraint module, it is
        less constrained. You can, however, use elements from constrained tasks by reference from
        unconstrained tasks because in that case the referenced elements are more constrained than
        the referencing elements.</p>
      <p>For example, suppose you defined a constraint module that removes <xmlelement>object</xmlelement>
        from the content model for <xmlelement>note</xmlelement>. If that constraint module were
        integrated with the task shell for the referencing task, but not with the task shell for the
        admonition set task, then it would not be possible to conref from the referencing task to
        the admonition set task because the referencing task is more constrained than the referenced
        task. On the other hand, if the admonition set topic used the constraint module and the
        referencing task did not, the conref would be fine because the referenced topic is more
        constrained than the referencing topic.</p>
      <p>Processors determine whether or not two DITA documents have consistent constraints by
                examining the value of the <xmlatt>domains</xmlatt> attribute on the root elements
                of the documents involved. The <xmlatt>domains</xmlatt> attribute lists all domain
                and constraint modules used by the document (and should list all structural modules
                used, but that is not required in DITA 1.2). By comparing their
                    <xmlatt>domains</xmlatt> values a processor can determine if two documents use
                the same set of domains and constraints or, in the case where one domain is a
                specialization of another domain, that the referenced document’s domains are all the
                same as or more specialized than the referencing element’s. See <xref
                    href="vocabulary-composition.xml#subsection_614fb512-4d88-4ece-b844-a7eb6341d4fa"
                    format="dita"/> for more about how DITA constraint module usage is declared.</p>
      <p>Note that for constraint modules, the referenced document must use the same or more constraints. For domain modules, the referenced document must use the same or fewer domains. This is because constraint modules limit what can be used, but domain modules extend what can be used, so fewer domain modules means more constrained (fewer things allowed).</p>
      <p>Note also that processors do not direct analyze content models on an element-type basis,
        they only compare the set of vocabulary and constraint modules used by the two documents
        involved in the conref relationship. This means that a processor might disallow a conref
        because the domain and constraint modules are not consistent, even though a human can
        inspect the content models of the elements involved and determine that the content models of
        those particular elements are consistent.</p>
      <p>In practice you should be working in an environment where all the topic and map types are
        managed as a whole, and therefore, whoever defines the document type shells can ensure that
        all the topic and map types use exactly the same domains and constraints or that map and
        topic types intended to hold reusable elements are as or more constrained than any map or
        topic type that would use those elements. In the second case, this might mean you need to
        create topic or map types that use the intersection of all domains used by the different
        topic or map types that might use those elements.</p>
      <p>Finally, note that many DITA-aware tools do not actually check or validate conref
        constraints, even though they should. This puts the burden on the people setting up DITA
        environments to ensure that the conref constraints will not violated by the references
        authors are likely to create and to train authors to understand what the constraints are.
        That way, authors will be less likely (or simply unable) to create content references that
        will be rejected by tools that do validate conref constraints.</p>
    </body>
  </subsection>
  <subsection
    id="ss2">
    <title>Reusing a Range of Elements: conref range</title>
    <shortdesc>You can reuse sequences of elements using the conref range facility.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref range</indexterm>
          <indexterm>conref<indexterm>using sequences of elements</indexterm></indexterm>
          <indexterm>range, conref</indexterm>
          <indexterm><xmlatt>conrefend</xmlatt> attribute</indexterm>
          <indexterm>attributes<indexterm><xmlatt>conrefend</xmlatt></indexterm></indexterm>
          <indexterm>constraints<indexterm>on conref range references</indexterm></indexterm>
          <indexterm>attributes<indexterm>merging through conref range</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>There are times when you want to re-use a sequence of elements as a unit, for example, a
                set of steps. You could, of course, create one conref for each element in the
                sequence, but that’s tedious and hard to maintain. DITA 1.2 adds the <q>conref
                    range</q> feature, which allows you to use a single element to reuse a sequence
                of elements. A conref range is not just a sequence of elements but a sequence of
                sibling nodes, meaning that the conref result will include any text or processing
                instruction nodes that occur between the start element and the end element, not just
                element nodes.</p>
      <p>You specify a conref range by pointing to the start of the range, as you would for a
        single-element conref, using <xmlatt>conref</xmlatt> or <xmlatt>conkeyref</xmlatt>. You then
        use <xmlatt>conrefend</xmlatt> to specify the ID of the last element in the range. </p>
      <p>For example, the following topic contains steps to be used by reference, bound to the key
          <q>step-set-01</q>:<codeblock>&lt;task id="reusable-steps">
  &lt;title>Reusable Steps&lt;/title>
  &lt;taskbody>
    &lt;steps>
      &lt;step id="step-01">...&lt;/step>
      &lt;step id="step-02">...&lt;/step>
      &lt;step id="step-03">...&lt;/step>
      &lt;step id="step-04">...&lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>You could pull in two or more of the steps like so:<codeblock>&lt;task id="task-id">
  ...
  &lt;steps>
    <b>&lt;step conkeyref="step-set-01/step-01"
          conrefend="dontcare.dita#topicid/step-03"
    /></b>
  &lt;/steps>
  ...
&lt;/task></codeblock></p>
      <p>Note that the value of <xmlatt>conrefend</xmlatt> is a direct DITA URI reference complete
        with fragment identifier. However, the only part of the reference that is actually relevant
        is the ID component, <q>step-03.</q></p>
      <p>That’s because when you use <xmlatt>conkeyref</xmlatt> the key reference determines the
                topic context for the conref end, meaning that everything except the element ID part
                of the <xmlatt>conrefend</xmlatt> value is ignored.</p>
      <p>If you are using <xmlatt>conref</xmlatt> and <xmlatt>conrefend</xmlatt>, then the address
        used in <xmlatt>conrefend</xmlatt> must point to the same topic as the address in
          <xmlatt>conref</xmlatt>. </p>
      <p>Of course, you cannot just refer to random sequences of elements willy-nilly. You must
        observe some constraints:<ol id="ol_lwv_bhv_hb">
          <li>The first and last elements of the range must have the same parent element.</li>
          <li>The parent element of the referencing element must be the same as or more specialized
            than the parent of the referenced elements.</li>
          <li>The first and last elements in the range must be of the same or more specialized types
            than the referencing element.</li>
        </ol></p>
      <p>This means you can pull sequences of list items into lists or steps into steps or
                paragraphs into a topic body. But, for example, you couldn’t use conref range to
                pull multiple notes from the admonition-set-01 document into a
                    <xmlelement>context</xmlelement> element, because the parent element of the
                    <xmlelement>note</xmlelement> elements is <xmlelement>body</xmlelement> in that example.</p>
      <p>While the start and end elements of a range must be of the same or more specialized types,
        that is not true of intermediate elements, so you could have a range of steps that includes
        one or more <xmlelement>stepsection</xmlelement> elements between the first and last
          <xmlelement>step</xmlelement> elements. Or you could use a <xmlelement>p</xmlelement> element to point
        to a range of elements bracketed by two <xmlelement>p</xmlelement> elements, but including between
        them anything valid in the parent element type.</p>
      <p>Note that one could construct specialized or constrained content models that would allow
        referenced ranges to be invalid. It would be a challenge to do so but it could happen. For
        example, if the content model were <codeph>(a, b, a, c, a, d)</codeph>, meaning a sequence
        of required elements that alternated the element type <codeph>a</codeph> with other types,
        you could reference the sequence <codeph>(a, b, a)</codeph>,  from the second
          <codeph>a</codeph> in the referencing topic, resulting in the effective element sequence
          <codeph>(a, b, a, b, a)</codeph>,  which would not be schema valid.</p>
      <p>There are no content models of this form in the base DITA vocabulary, but nothing prevents
        someone from defining one in a specialization or constraint module. But it is highly
        unlikely anyone would define something like this except for the most specialized and
        task-specific applications. </p>
      <p>Also, remember that validity doesn’t just mean what the DTD or schema enforces, it means
                what the processors that operate on the data do or don’t accept. If trapping this
                case and reporting is important, you can always check using a separate validation
                application like Schematron or custom code.</p>
      <p>The rules for attribute merging are a bit more complicated. Attributes specified on the
        referencing element get merged to all the sibling elements in the referenced range (but not
        to descendants of the elements in the range). In a conref processor that creates a literal
        result document, it is up to the processor to rewrite IDs and references in the referenced
        elements to ensure that all addresses in the resolved result are correct and
        unambiguous.</p>
    </body>
  </subsection>
  <subsection
    id="ss3">
    <title>Unilateral Change: Conref Push (<xmlatt>conaction</xmlatt> attribute)</title>
    <shortdesc>The conref push feature lets you replace elements in, or impose additional elements
            into, topics or maps, allowing you to change or extend content you can’t or shouldn’t
            modify directly.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>attributes<indexterm><xmlatt>conaction</xmlatt></indexterm></indexterm>
          <indexterm><xmlatt>conaction</xmlatt> attribute</indexterm>
          <indexterm>conref<indexterm>push</indexterm></indexterm>
          <indexterm>push conref</indexterm>
          <indexterm>unilateral change to content using conref push</indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>Because DITA enables true blind interchange, it means you might be in a situation where you
                get content from a third party, such as a publisher, a supplier of product
                subcomponents, or another business unit in your company. You can easily integrate
                this content into your publications using maps. What you can’t, or shouldn’t, do is
                modify the content after you get it.</p>
      <p>However, there is often a need to change or extend third-party content to reflect your use
        of it, perhaps to add commentary to regulations or to add use-context-specific or
        product-specific information to otherwise generic topics.</p>
      <p>This requirement is addressed by the DITA 1.2 conref push facility, expressed through the
                    <xmlatt>conaction</xmlatt> attribute. Conref push lets you point into a map or a
                topic and link elements before or after an element, making them effectively part of
                the topic or map linked to. You can also replace elements in the referenced context
                with pushed elements.</p>
      <p>For example, given a generic task for a common subcomponent of a larger product, you could use conref push to add product-specific steps to the generic task or to replace generic steps or context information with product-specific information.</p>
      <p>You create a push conref by creating a topic that holds the content to be pushed and that
        points at the topic to be pushed to. Within the topic to be pushed to, the elements that
        serve as the push targets must have IDs, just as for any other use of conref. You then
        include both topics in your map. Normally you would include the pushing topic with a
        processing role of <q>resource-only</q> since its only purpose is to push content to another
        topic that is, presumably, in the main navigation flow of the publication.</p>
      <p>The possible actions for conref push are <q>pushreplace,</q>
        <q>pushbefore,</q> and <q>pushafter,</q> and they mean exactly what their names suggest.</p>
      <p>The <q>pushreplace</q> action completely replaces the referenced element with the
        referencing element.</p>
      <p>The <q>pushbefore</q> and <q>pushafter</q> actions put the referencing element before or
                after the referenced element, respectively. For pushes, the same constraints as for
                conref range hold: the pushed element must be the same type or more specialized than
                the referenced element and both elements must have the same type of parent or the
                pushed element’s parent must be more specialized than the referenced element’s
                parent. This helps ensure that the result of the push is schema valid.</p>
      <p>When you use a <xmlatt>conaction</xmlatt> of <q>pushbefore</q> or <q>pushafter</q> you must
                also create an instance of the same element type as the pushing element that uses a
                    <xmlatt>conaction</xmlatt> value of <q>mark.</q> Effectively the <q>marker</q>
                element serves as a local proxy for the target element you’re pushing relative to
                and helps ensure that the resolved result will be schema valid. The marker element
                points to the same element as the pushing element.</p>
      <p>Because the <q>marker</q> element serves as a proxy for the target of the push, it goes in
                the same position relative to the pushing element as the pushed element will be
                relative to the referenced element. Thus, for an action of "push after", the marker
                element goes before the pushing element, and for an action of "push before," the
                marker element goes after the pushing element. Both cases are shown in the example
                below. Consider this task topic, bound to the key
                <q>generic-task-01</q>:<codeblock>&lt;task id="generic-task">
  &lt;title>&lt;ph id="title-text">Some Generic Task&lt;/ph>&lt;/title>
  &lt;taskbody>
    &lt;context id="context">
     &lt;p>This is the generic context.&lt;/p>
    &lt;/context>
    &lt;steps>
      &lt;step id="step-first">
        &lt;cmd>The first thing you do.&lt;/cmd>
      &lt;/step>
      ...
      &lt;step id="step-last">
        &lt;cmd>The last thing you do.&lt;/cmd>
      &lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>You could use conref push to both replace the
        <xmlelement>context</xmlelement> element with a product-specific one and
        insert new steps before or after the first or last steps. You do this by
        creating a separate task
        topic:<codeblock>&lt;task id="push-to-generic">
  &lt;title>Conref push task&lt;/title>
  &lt;taskbody>
<ph outputclass="callout">[1]</ph> <b>&lt;context
      conkeyref="generic-task-01/context"
      conaction="pushreplace"
    ></b>
     &lt;p>This is product-specific context.&lt;/p>
    <b>&lt;/context></b>
    &lt;steps>
<ph outputclass="callout">[2]</ph>   <b>&lt;step
        conkeyref="generic-task-01/step-first"
        conaction="pushbefore"
      ></b>
        &lt;cmd>Do this before you do anything else.&lt;/cmd>
      <b>&lt;/step></b>
<ph outputclass="callout">[3]</ph> &lt;step
        conkeyref="generic-task-01/step-first"
        conaction="mark">
        &lt;!-- Required marker element for the push-before action.
            
             Goes after the pushing element (same relative position
             as the referenced element).
          -->
       &lt;cmd/>&lt;/step>
<ph outputclass="callout">[4]</ph>  &lt;step
        conkeyref="generic-task-01/step-last"
        conaction="mark">
        &lt;!-- Required marker element for the push-after action 
            
             Goes before the pushing element (same relative position
             as the referenced element).
          -->
        &lt;cmd/>&lt;/step>
<ph outputclass="callout">[5]</ph>   <b>&lt;step
        conkeyref="generic-task-01/step-last"
        conaction="pushafter"
      ></b>
        &lt;cmd>Do this after you do everything else.&lt;/cmd>
      <b>&lt;/step></b>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>In this topic, note the following key bits:<dl id="ul_vqy_fpd_ib">
                    <dlentry>
                        <dt>[1]</dt>
                        <dd>A push that replaces the referenced topic’s <xmlelement>context</xmlelement>
                            element with this element.</dd>
                    </dlentry>
                    <dlentry>
                        <dt>[2]</dt>
                        <dd>A step that is pushed before the step with the id <q>step-first</q> in
                            the referenced topic</dd>
                    </dlentry>
                    <dlentry>
                        <dt>[3]</dt>
                        <dd>The required marker element for the push-before. It occurs in the same
                            position relative to the pushing element as the referenced element will
                            be relative to the pushing element, after is pushed. This requirement
                            ensures that the pushed element will be valid in the location it is
                            pushed into.<p>The marker <xmlelement>step</xmlelement> elements have empty
                                    <xmlelement>cmd</xmlelement> elements. This is because the content
                                model for <xmlelement>step</xmlelement> requires <xmlelement>cmd</xmlelement>,
                                so it has to be there in order for the document to be schema valid
                                even though the element’s content is ignored.</p></dd>
                    </dlentry>
                    <dlentry>
                        <dt>[4]</dt>
                        <dd>The required marker element for the push-after.</dd>
                    </dlentry>
                    <dlentry>
                        <dt>[5]</dt>
                        <dd>A step that is pushed after the last step in the referenced topic. Note
                            that it must occur <i>after</i> its corresponding marker element.</dd>
                    </dlentry>
                </dl></p>
      <p>You would then include both topics in a map like
                so:<codeblock>&lt;map>
 &lt;topicgroup 
   processing-role="resource-only">
   <b>&lt;topicref 
      href="prod-specific/tasks/push-to-generic-task-01.dita"
      
   ></b>
 &lt;/topicgroup>
 ...
 &lt;topichead>
   &lt;topicmeta>
     &lt;navtitle>Product-Specific Manual&lt;/navtitle>
   &lt;/topicmeta>
   ...
   <b>&lt;topicref
     keys="generic-task-01"
     href="common/tasks/generic-task-01.dita"
   /></b>
   ...
 &lt;/topichead>
&lt;/map></codeblock></p>
      <p>The first topicref in the map pulls in the pushing task as a resource. This makes the topic
                available to the processor but doesn’t include it in the main navigation hierarchy
                of the map. Note that the <xmlatt>processing-role</xmlatt> attribute on the
                containing <xmlelement>topicgroup</xmlelement> makes all the topicrefs within the
                    <xmlelement>topicgroup</xmlelement> into resource-only topicrefs, which is what we
                want for the reference to the pushing topic.</p>
      <p>The second topicref pulls in the generic task with the (default) processing role of
          <q>normal,</q> which includes it in the main navigation hierarchy. The topicref also binds
        the key <q>generic-task-01</q> to the topic.</p>
      <p>The processing result is that the rendered result of processing
          <filepath>generic-task-01.dita</filepath> at that location in the map will reflect the
        replacement of the original <xmlelement>context</xmlelement> element with the one from the pushing
        task, the insertion of a new step before step <q>step-first</q> and a new step after step
          <q>step-last.</q> The result will be the equivalent of the following
        task:<codeblock>&lt;task id="generic-task">
  &lt;title>&lt;ph id="title-text">Some Generic Task&lt;/ph>&lt;/title>
  &lt;taskbody>
    &lt;context id="context"
    >
     &lt;p>This is product-specific context.&lt;/p>
    &lt;/context>
    &lt;steps>
      &lt;step
      >
        &lt;cmd>Do this before you do anything else.&lt;/cmd>
      &lt;/step>
      &lt;step id="step-first">
        &lt;cmd>The first thing you do.&lt;/cmd>
      &lt;/step>
      ...
      &lt;step id="step-last">
        &lt;cmd>The last thing you do.&lt;/cmd>
      &lt;/step>
      &lt;step
      >
        &lt;cmd>Do this after you do everything else.&lt;/cmd>
      &lt;/step>
    &lt;/steps>
  &lt;/taskbody>
&lt;/task></codeblock></p>
      <p>Finally, note that in DITA 1.2 conref push can only be used for single elements, not for ranges. This restriction is to avoid cases where the resolved result would not be schema valid. </p>
      <p>It might seem that if you wanted to generate two different versions of
        the same generic topic in the same use context, you could create two
        different keys pointing to that topic, then push different content by
        creating two referencing elements, each using one of the keys. However,
        the DITA TC has ruled that no matter how many times you try to push into
        a given topic, there will only be one result topic. In the case where
        two topics push into the same topic, the result is undefined.</p>
    </body>
  </subsection>
  <subsection
    id="ss4">
    <title>Content Reference Data Management Strategies</title>
    <shortdesc>Management of conref references requires you to follow a few general
      practices.</shortdesc>
    <prolog>
      <metadata>
        <keywords>
          <indexterm>conref<indexterm>management strategies for</indexterm></indexterm>
          <indexterm>data management strategies<indexterm>for conref</indexterm></indexterm>
          <indexterm>data management strategies<indexterm>for conref push</indexterm></indexterm>
        </keywords>
      </metadata>
    </prolog>
    <body>
      <p>To recap the general practices for making conref manageable:<ul
        id="ul_yyu_fqj_ib">
        <li>Use keys and <xmlatt>conkeyref</xmlatt> to avoid hard topic-to-topic
          dependencies and to make your content more flexible.</li>
        <li>Use meaningful and consistent IDs on elements that are intended to be or may be the
            targets of conref links.</li>
        <li>Establish clear business rules and policies for what <i>must</i> be used by reference, what <i>may</i> be used by reference, and what <i>should not</i> be used by reference. In general, do not allow arbitrary use by reference.</li>
        <li>Organize content to be used by reference into specific areas on the file system or within your content repository.</li>
        <li>Use domain and constraint modules consistently to ensure that all allowed or appropriate referencing and referenced documents satisfy the content reference constraint rules for consistency of vocabulary and constraint use.</li>
        <li>To enable conref push, put <xmlatt>id</xmlatt> attributes on useful push targets. Note
            that putting IDs on elements effectively establishes extension points in your content.
            If your content is intended for or likely to be used by third parties who will want to
            extend it, you should document your policies and practices for enabling conref
            push.</li>
        </ul></p>
    </body>
  </subsection>
</chapter>
